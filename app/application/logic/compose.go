package logic

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/compose-spec/compose-go/v2/cli"
	"github.com/donknap/dpanel/common/accessor"
	"github.com/donknap/dpanel/common/dao"
	"github.com/donknap/dpanel/common/entity"
	"github.com/donknap/dpanel/common/function"
	"github.com/donknap/dpanel/common/migrate"
	"github.com/donknap/dpanel/common/service/compose"
	"github.com/donknap/dpanel/common/service/docker"
	"github.com/donknap/dpanel/common/service/exec"
	"github.com/donknap/dpanel/common/service/storage"
	"io"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

const (
	ComposeTypeText        = "text"
	ComposeTypeRemoteUrl   = "remoteUrl"
	ComposeTypeServerPath  = "serverPath"
	ComposeTypeStoragePath = "storagePath"
	ComposeStatusWaiting   = "waiting"
)

type Compose struct {
}

type composeItem struct {
	Name        string `json:"name"`
	Status      string `json:"status"`
	ConfigFiles string `json:"configFiles"`
}

func (self Compose) Ls(projectName string) []*composeItem {
	command := []string{
		"ls",
		"--format", "json",
		"--all",
	}
	if projectName != "" {
		command = append(command, "--filter", "name="+projectName)
	}
	out := exec.Command{}.RunWithOut(&exec.RunCommandOption{
		CmdName: "docker",
		CmdArgs: append(append(docker.Sdk.ExtraParams, "compose"), command...),
	})
	result := make([]*composeItem, 0)
	err := json.Unmarshal([]byte(out), &result)
	if err != nil {
		return result
	}
	return result
}

func (self Compose) Kill() error {
	return exec.Command{}.Kill()
}

func (self Compose) Sync() error {
	composeList, _ := dao.Compose.Find()

	composeFileName := []string{
		"docker-compose.yml", "docker-compose.yaml",
		"compose.yml", "compose.yaml",
	}
	rootDir := storage.Local{}.GetComposePath()
	err := filepath.Walk(rootDir, func(path string, info fs.FileInfo, err error) error {
		for _, suffix := range composeFileName {
			if strings.HasSuffix(path, suffix) {
				rel, _ := filepath.Rel(rootDir, path)
				// 只同步二级目录下的 yaml
				if segments := strings.Split(filepath.Clean(rel), string(filepath.Separator)); len(segments) == 2 {
					name := filepath.Dir(rel)

					has := false
					for _, item := range composeList {
						if item.Name == name {
							has = true
							break
						}
					}

					if !has {
						dao.Compose.Create(&entity.Compose{
							Title: "",
							Name:  name,
							Yaml:  rel,
							Setting: &accessor.ComposeSettingOption{
								Type:   ComposeTypeStoragePath,
								Status: ComposeStatusWaiting,
								Uri:    rel,
							},
						})
					}
				}
				break
			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	return nil
}

func (self Compose) GetTasker(entity *entity.Compose) (*compose.Task, error) {
	options := make([]cli.ProjectOptionsFn, 0)
	options = append(options, cli.WithName(entity.Name))

	// 生成 .env 文件
	if !function.IsEmptyArray(entity.Setting.Environment) {
		envFilePath := filepath.Join(storage.Local{}.GetComposePath(), entity.Name, ".env")
		envList := make([]string, 0)
		for _, item := range entity.Setting.Environment {
			envList = append(envList, fmt.Sprintf("%s=%s", item.Name, item.Value))
		}
		err := os.WriteFile(envFilePath, []byte(strings.Join(envList, "\n")), 0666)
		if err != nil {
			return nil, err
		}
		options = append(options, cli.WithEnv(envList))
	}

	yamlFilePath := ""
	if entity.Setting.Type == ComposeTypeServerPath {
		yamlFilePath = entity.Setting.Uri
	} else if entity.Setting.Type == ComposeTypeStoragePath {
		yamlFilePath = filepath.Join(storage.Local{}.GetComposePath(), entity.Setting.Uri)
	} else {
		yamlFilePath = filepath.Join(storage.Local{}.GetComposePath(), entity.Name, "compose.yaml")
		err := os.MkdirAll(filepath.Dir(yamlFilePath), os.ModePerm)
		if err != nil {
			return nil, err
		}
		if entity.Setting.Type == ComposeTypeRemoteUrl {
			response, err := http.Get(entity.Yaml)
			if err != nil {
				return nil, err
			}
			defer func() {
				_ = response.Body.Close()
			}()
			content, err := io.ReadAll(response.Body)
			if err != nil {
				return nil, err
			}
			entity.Yaml = string(content)
		}
		err = os.WriteFile(yamlFilePath, []byte("# 此文件由 dpanel 面板生成，请勿修改！ \n# Generated by dpanel, do not modify!\n"+entity.Yaml), 0666)
		if err != nil {
			return nil, err
		}
	}
	options = append(options, compose.WithYamlPath(yamlFilePath))
	composer, err := compose.NewCompose(options...)
	if err != nil {
		return nil, err
	}

	// 生成覆盖配置时，需要获取原始yaml的数据，所以这里生构建出原始的compose对象，再进行覆盖。
	// 生成覆盖Yaml
	if !function.IsEmptyArray(entity.Setting.Override) {
		yamlOverrideFilePath := filepath.Join(storage.Local{}.GetComposePath(), entity.Name, "compose-override.yaml")
		err = os.MkdirAll(filepath.Dir(yamlOverrideFilePath), os.ModePerm)
		if err != nil {
			return nil, err
		}
		overrideProject := migrate.Upgrade20241014{}.Covert(entity.Setting.Override)
		for serviceName, serviceItem := range overrideProject.Services {
			newDependsOn := composer.Project.Services[serviceName].DependsOn
			for _, linkName := range serviceItem.ExternalLinks {
				links := strings.Split(linkName, ":")
				if _, ok := composer.Project.Services[serviceName].DependsOn[links[1]]; ok {
					delete(newDependsOn, links[1])
				}
			}
			serviceItem.DependsOn = newDependsOn
			overrideProject.Services[serviceName] = serviceItem
		}
		overrideYaml, err := overrideProject.MarshalYAML()
		if err != nil {
			return nil, err
		}
		// ports 配置要覆盖原始文件
		overrideYaml = bytes.Replace(overrideYaml, []byte("ports:"), []byte("ports: !override"), -1)
		overrideYaml = bytes.Replace(overrideYaml, []byte("depends_on:"), []byte("depends_on: !override"), -1)

		err = os.WriteFile(
			yamlOverrideFilePath,
			append(
				[]byte("# 此文件由 dpanel 面板生成，请勿修改！ \n# Generated by dpanel, do not modify!\n"),
				overrideYaml...,
			), 0666)
		if err != nil {
			return nil, err
		}
		options = append(options, compose.WithYamlPath(yamlOverrideFilePath))
	}
	composer, err = compose.NewCompose(options...)

	if err != nil {
		return nil, err
	}
	tasker := compose.NewTasker(entity.Name, composer)
	return tasker, nil
}
