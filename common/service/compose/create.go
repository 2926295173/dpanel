package compose

import (
	"context"
	"errors"
	"fmt"
	"github.com/compose-spec/compose-go/v2/cli"
	"github.com/compose-spec/compose-go/v2/types"
	"github.com/docker/go-units"
	"github.com/donknap/dpanel/common/accessor"
	"github.com/donknap/dpanel/common/function"
	"github.com/donknap/dpanel/common/service/docker"
	"github.com/donknap/dpanel/common/service/storage"
	"log/slog"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

func WithYamlPath(path string) cli.ProjectOptionsFn {
	return func(options *cli.ProjectOptions) error {
		options.ConfigPaths = append(options.ConfigPaths, path)
		return nil
	}
}

func WithYamlContent(content ...string) cli.ProjectOptionsFn {
	return func(options *cli.ProjectOptions) error {
		if !function.IsEmptyArray(options.ConfigPaths) {
			return errors.New("already configured yaml file path")
		}
		tempPath, _ := storage.Local{}.CreateTempDir("")
		tempEnvFile := filepath.Join(tempPath, ".env")
		for i, c := range content {
			tempComposeFile := filepath.Join(tempPath, fmt.Sprintf("compose.%d.yaml", i))
			err := os.WriteFile(
				tempComposeFile,
				append([]byte("# 此文件由 dpanel 面板生成，请勿修改！ \n# Generated by dpanel, do not modify!\n"), []byte(c)...),
				0666,
			)
			if err != nil {
				slog.Debug("compose create withYamlContent", "err", err)
			}
			options.ConfigPaths = append(options.ConfigPaths, tempComposeFile)
		}

		if !function.IsEmptyMap(options.Environment) {
			err := os.WriteFile(tempEnvFile, []byte(strings.Join(options.Environment.Values(), "\n")), 0666)
			if err != nil {
				slog.Debug("compose create withYamlContent", "err", err)
			}
		}

		options.EnvFiles = append(options.EnvFiles, tempEnvFile)
		return nil
	}
}

func WithDockerEnvItem(envItem ...docker.EnvItem) cli.ProjectOptionsFn {
	return func(options *cli.ProjectOptions) error {
		if function.IsEmptyArray(envItem) {
			return nil
		}
		if function.IsEmptyMap(options.Environment) {
			options.Environment = make(types.Mapping)
		}
		for _, item := range envItem {
			options.Environment[item.Name] = item.Value
		}
		return nil
	}
}

func NewCompose(opts ...cli.ProjectOptionsFn) (*Wrapper, error) {
	// 自定义解析
	opts = append(opts,
		cli.WithExtension(ExtensionName, Ext{}),
		cli.WithExtension(ExtensionServiceName, ExtService{}),
	)
	options, err := cli.NewProjectOptions(
		[]string{},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	project, err := options.LoadProject(context.Background())
	if err != nil {
		return nil, err
	}
	wrapper := &Wrapper{
		Project: project,
	}
	return wrapper, nil
}

func NewComposeBySiteEnvMap(options map[string]accessor.SiteEnvOption) (*Wrapper, error) {
	arr := make([]accessor.SiteEnvOption, 0)
	for _, option := range options {
		arr = append(arr, option)
	}
	return NewComposeBySiteEnv(arr...)
}

func NewComposeBySiteEnv(options ...accessor.SiteEnvOption) (*Wrapper, error) {
	// 完全适配 compose spec 的参数
	project := types.Project{
		Services: map[string]types.ServiceConfig{},
		Networks: make(types.Networks),
		Volumes:  make(types.Volumes),
	}
	extProject := Ext{
		DisabledServices: make([]string, 0),
	}

	for _, siteOption := range options {
		service := types.ServiceConfig{
			Name:          siteOption.Name,
			Image:         siteOption.ImageName,
			ExternalLinks: make([]string, 0),
			Ports:         make([]types.ServicePortConfig, 0),
			Volumes:       make([]types.ServiceVolumeConfig, 0),
			Networks:      map[string]*types.ServiceNetworkConfig{},
			Privileged:    siteOption.Privileged,
			Restart:       siteOption.Restart,
			CPUS:          siteOption.Cpus,
			MemLimit:      types.UnitBytes(siteOption.Memory * 1024 * 1024),
			WorkingDir:    siteOption.WorkDir,
			User:          siteOption.User,
			//Command:       make(types.ShellCommand, 0),
			//Entrypoint:    make(types.ShellCommand, 0),
			LogDriver:  "",
			LogOpt:     make(map[string]string),
			DNS:        siteOption.Dns,
			Labels:     make(types.Labels),
			ExtraHosts: make(types.HostsList),
		}
		extService := ExtService{
			External: ExternalItem{
				VolumesFrom: make([]string, 0),
				Volumes:     make([]string, 0),
			},
			AutoRemove: siteOption.AutoRemove,
			Ports: PortsItem{
				BindIPV6:   siteOption.BindIpV6,
				PublishAll: siteOption.PublishAllPorts,
			},
		}

		if !function.IsEmptyArray(siteOption.Environment) {
			envList := function.PluckArrayWalk(siteOption.Environment, func(i docker.EnvItem) (string, bool) {
				return fmt.Sprintf("%s=%s", i.Name, i.Value), true
			})
			service.Environment = types.NewMappingWithEquals(envList)
		}

		// links 对应 compose 中的 external_links
		if !function.IsEmptyArray(siteOption.Links) {
			for _, item := range siteOption.Links {
				service.ExternalLinks = append(service.ExternalLinks, fmt.Sprintf("%s:%s", item.Name, item.Alise))
				if item.Volume {
					extService.External.VolumesFrom = append(extService.External.VolumesFrom, item.Name)
				}
			}
		}

		for _, item := range siteOption.Ports {
			target, _ := strconv.Atoi(item.Dest)
			service.Ports = append(service.Ports, types.ServicePortConfig{
				HostIP:    item.HostIp,
				Target:    uint32(target),
				Published: item.Host,
			})
		}

		for _, item := range siteOption.Volumes {
			if !strings.Contains(item.Host, "/") {
				service.Volumes = append(service.Volumes, types.ServiceVolumeConfig{
					Type:     types.VolumeTypeVolume,
					Source:   item.Host,
					Target:   item.Dest,
					ReadOnly: item.Permission == "read",
				})
				project.Volumes[item.Host] = types.VolumeConfig{
					Name: item.Host,
				}
			} else {
				service.Volumes = append(service.Volumes, types.ServiceVolumeConfig{
					Type:     types.VolumeTypeBind,
					Source:   item.Host,
					Target:   item.Dest,
					ReadOnly: item.Permission == "read",
				})
			}
		}

		for _, item := range siteOption.Network {
			service.Networks[item.Name] = &types.ServiceNetworkConfig{
				Aliases:     item.Alise,
				Ipv4Address: item.IpV4,
				Ipv6Address: item.IpV6,
			}
			projectNetworkConfig := types.NetworkConfig{
				Name:     item.Name,
				External: true,
			}
			project.Networks[item.Name] = projectNetworkConfig
		}

		if siteOption.ShmSize != "" {
			size, _ := units.RAMInBytes(siteOption.ShmSize)
			service.ShmSize = types.UnitBytes(size)
		}

		if siteOption.Command != "" {
			service.Command = docker.CommandSplit(siteOption.Command)
		}

		if siteOption.Entrypoint != "" {
			service.Entrypoint = docker.CommandSplit(siteOption.Entrypoint)
		}

		if siteOption.UseHostNetwork {
			service.NetworkMode = "host"
		}

		if siteOption.Log != nil && siteOption.Log.Driver != "" {
			loggingOpts := &types.LoggingConfig{
				Driver:  siteOption.Log.Driver,
				Options: make(types.Options),
			}
			if siteOption.Log.MaxSize != "" {
				loggingOpts.Options["max-size"] = siteOption.Log.MaxSize
			}
			if siteOption.Log.MaxFile != "" {
				loggingOpts.Options["max-file"] = siteOption.Log.MaxFile
			}
			service.Logging = loggingOpts
		}

		for _, item := range siteOption.Label {
			service.Labels[item.Name] = item.Value
		}

		hostList := function.PluckArrayWalk(siteOption.ExtraHosts, func(i docker.ValueItem) (string, bool) {
			if i.Name == "" || i.Value == "" {
				return "", false
			}
			return fmt.Sprintf("%s=%s", i.Name, i.Value), true
		})

		if !function.IsEmptyArray(hostList) {
			hostLists, err := types.NewHostsList(hostList)
			if err != nil {
				service.ExtraHosts = make(types.HostsList)
			} else {
				service.ExtraHosts = hostLists
			}
		}

		service.Extensions = map[string]any{
			ExtensionServiceName: extService,
		}

		if siteOption.IpV4 != nil || siteOption.IpV6 != nil {
			projectNetworkConfig := types.NetworkConfig{
				Name: siteOption.Name,
				Ipam: types.IPAMConfig{
					Driver: "default",
					Config: make([]*types.IPAMPool, 0),
				},
			}

			networkConfig := &types.ServiceNetworkConfig{}
			if siteOption.IpV4.Address != "" {
				networkConfig.Ipv4Address = siteOption.IpV4.Address
				projectNetworkConfig.Ipam.Config = append(projectNetworkConfig.Ipam.Config, &types.IPAMPool{
					Subnet:  siteOption.IpV4.Subnet,
					Gateway: siteOption.IpV4.Gateway,
				})
			}
			if siteOption.IpV6.Address != "" {
				projectNetworkConfig.EnableIPv6 = function.PtrBool(true)
				networkConfig.Ipv6Address = siteOption.IpV6.Address
				projectNetworkConfig.Ipam.Config = append(projectNetworkConfig.Ipam.Config, &types.IPAMPool{
					Subnet:  siteOption.IpV6.Subnet,
					Gateway: siteOption.IpV6.Gateway,
				})
			}
			service.Networks[siteOption.Name] = networkConfig
			project.Networks[siteOption.Name] = projectNetworkConfig
		}
		project.Services[siteOption.Name] = service
	}
	project.Extensions = map[string]any{
		ExtensionName: extProject,
	}
	return &Wrapper{
		Project: &project,
	}, nil
}
